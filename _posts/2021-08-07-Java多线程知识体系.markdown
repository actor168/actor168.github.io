---
layout: post
title:  "Java多线程知识体系"
date:   2021-08-07 12:00:00 +0800
categories: Java 多线程
---
1. 认识多线程及`Java`多线程

- 线程和进程的区别

进程，是操作系统进行资源分配和调度的独立单位。操作系统管理CPU、内存、文件、网络等资源，同时也管理着软件程序的执行，操作系统在运行程序时，将进程作为资源的分配单位进行资源分配。

线程，是CPU调度执行的最小单位。线程作为进程的一部分，线程共享进程的上下文、内存、文件、网络等资源，仅仅是运行的CPU有所不同，是面向于多核CPU后出现的概念，从而实现了真正意义的并行。

进程=PCB（进程控制块=进程描述信息+进程控制和管理信息+资源分配清单+处理机相关信息）+程序+数据

- 线程间通信

线程间通信的方法一般有：共享内存、消息传递、管道。

共享内存：比如使用`volatile`, `mutex`, `condtion variable`
消息传递：
管道：`channel`

- `Java`线程

`Java`中`JVM`内置多线程支持，通过`Thread`类实现，通过创建`Thread`对象，即可实现多线程，并通过`start()`方法来运行。

- `Java`线程的使用

* 直接使用`Thread`

```java
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread() {
            public void run(){
                System.out.println("Thread Running");
            }
        }
        thread.start();
    }
}
```
* 实现`Runnable`接口 

```java
public interface Runnable() {
    public void run();
}
```
样例
```java
class MyThread implements Runnable {
    @override
    public void run() {
        System.out.println("Thread Running");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new MyThread();
        thread.start();
    }
}
```

* 实现`Callable`接口

```java
public interface Callable<V> {
    V call() throws Exception;
}
```
样例
```java
class FactorialTask implements Callable<Integer> {
    int number;

    // standard constructors

    public Integer call() throws InvalidParamaterException {
        int fact = 1;
        // ...
        for(int count = number; count > 1; count--) {
            fact = fact * count;
        }

        return fact;
    }
}

public class Main {
    public static void main(String[] args) {
        FactorialTask task = new FactorialTask(5);
        Future<Integer> future = Executors.newSingleThreadExecutor().submit(task);
        System.out.println(future.get().intValue());
    }
}
```

- `Java`中关于`Thread`的相关方法

1.  `Thread`的`sleep()`, `yield()`  
线程休眠，但并不释放锁。

2. `Object`的`wait()`, `notify()`, `notifyAll()`  
线程被加入等待集合后，释放对象的锁。这是与sleep显著的不同
每个`Java`对象包含一个等待集合`wait set`，wait的本质还是对象的锁操作和将线程加入对象的等待集合的操作，调用wait，就会将线程放置于等待集合，调用当前object多少次wait()，就会在对象上加多少次由线程施加的lock行为的unlock操作，一旦被`notify`或`interrupt`后，又会重新加上lock。

```java
public class WaitNotify {
    public static void main(String[] args) throws InterruptedException {
        MyObj obj = new MyObj();
        Thread t = new Thread() {
            @Override
            public void run() {
                synchronized(obj) { // 此处必须先获取obj的锁，否则会报IllegalMonitorStateException
                    try {
                        System.out.println("线程获取了obj锁");
                        System.out.println("线程将要运行obj.wait()方法进行等待");
                        obj.wait();
                        System.out.println("线程等待结束");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t.start();
        Thread.sleep(1000);
        synchronized(obj) {
            obj.notify();
        }
    }
}
```

* `interrput()`

* `Java`内存模型

CPU的高速缓存是每个CPU所独享的，在多线程的环境下，就会出现X修改了值，在未回写内存的情况下，被Y使用，从而造成数据不一致的问题。
同时，由于存在编译器的优化，会对指令重排序，从而造成执行过程不确定。
为了解决上述问题，
内存模型描述给定程序和该程序的执行跟踪，执行跟踪是否为程序的合法执行。Java编程语言内存模型的工作原理是检查执行跟踪中的每个读取，并根据某些规则检查该读取观察到的写入是否有效。内存模型描述了一个程序可能发生的行为。

2. `volatile`关键字

> volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

```java
public class Volatile { 
    int o = 0;
    void set() { o++; }
    public static void main(String[] args) throws InterruptedException {
        Volatile o = new Volatile();
        Thread t = new Thread() {
            @Override
            public void run() {
                while(o.o != 1) { System.out.println("working a..."); }
                System.out.println("worked a ...");
            }   
        };
        Thread t1 = new Thread() {
            @Override
            public void run() {
                while(o.o == 0) {
                    o.set();
                    System.out.println("working b ...");
                }
                System.out.println("worked b ...");
            }   
        };
        t.start();
        t1.start();
        Thread.sleep(1000);
    }
}
```

3. `synchronized`关键字  
`Java`内置关键字，通过`monitorenter`和`monitorexit`实现该能力，其实是对对象加锁。具有原子性、可见性、可重入性、重量级锁等特点。  
可以放置的地方如：
- 代码块

```java
synchronized {
    this.account++;
}
```
- 方法

```java
synchronized void transfer() {
    ...
}
```

- 对象

```java
static int account;
static synchronized method {
    this.account++;
}
```

`synchronized`是可重入锁，可重入锁是指以线程为单位，当一个线程在获取对象锁后，这个线程可以再次获取该对象的锁，而其他线程不可以。

- 可重入锁原理  
通过记录对象上锁的线程及数量来控制可重入性。
+ 调用`synchronized`代码时，检查该对象是否已经被锁，如果被锁，判断是否被当前线程锁定，如是，则计数加1；否则，加入等待队列。
+ 退出`synchronized`，将计数减1，直到为0，则释放锁。  
对象头，2个字的空间，包括：markword(synchronization+gc+hashcode)+object-ptr

- 偏向锁、轻量级锁、重量级锁概念  
**偏向锁**  
介于无锁和轻量级锁之间的一种状态，由markword记录当前所占用对象的thread id  
（1）初始时对象处于biasable状态，并且ThreadID为0即biasable & unbiased状态（这里不讨论epoch和age）  
（2）当一个线程试图锁住一个处于biasable & unbiased状态的对象时，通过一个CAS将自己的ThreadID放置到Mark Word中相应的位置，如果CAS操作成功进入第（3）步否则进入（4）步  
（3）当进入到这一步时代表当前没有锁竞争，Object继续保持biasable状态，但是这时ThreadID字段被设置成了偏向锁所有者的ID，然后进入到第（6）步  
（4）当前线程执行CAS获取偏向锁失败（这一步是偏向锁的关键），表示在该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁所有权。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，并从偏向锁所有者的私有Monitor Record列表中获取一个空闲的记录，并将Object设置为LightWeight Lock状态并且Mark Word中的LockRecord指向刚才持有偏向锁线程的Monitor record，最后被阻塞在安全点的线程被释放，进入到轻量级锁的执行路径中，同时被撤销偏向锁的线程继续往下执行同步代码。  
（5）当一个线程试图锁住一个处于biasable & biased并且ThreadID不等于自己的ID时，这时由于存在锁竞争必须进入到第（4）步来撤销偏向锁。  
（6）运行同步代码块  
**轻量级锁**  
偏向锁->竞争->轻量级锁->OS Mutex->重量级锁  
轻量级锁会将被锁的对象的markword复制写入栈，形成lock record，并通过CAS将markword指向lock record。如果指向成功，则获取了对象锁。如果失败，则会膨胀，对象的markword会被os mutex和变量所CAS设置。解锁时过程一致，先去试图CAS lock record，如果失败，则CAS os mutex。  
**重量级锁**    
os mutex互斥锁

4. 锁

* `Lock`  

`Lock`提供了对共享资源的独占访问：一次只有一个线程可以获得该锁，而对该共享资源的所有访问都需要首先获取该锁，JUC包中的`Lock`提供比`synchronized`更为灵活的使用方式，例如，一些遍历并发访问的数据结构的算法需要使用“移交”或“链锁”：获取节点A的锁，然后是节点B，然后释放A并获取C，然后释放B，然后获取D等等。锁接口的实现通过允许在不同的范围内获取和释放一个锁，并允许以任何顺序对多个锁进行获取和释放，从而允许使用这些技术。随着这种灵活性的增加，又增加了额外的责任。 
```java
 Lock l = ...;
 l.lock();
 try {
   // access the resource protected by this lock
 } finally {
   l.unlock();
 }
```

```java
interface Lock {
    void lock();
    void lockInterruptibly();
    Condition newCondition();
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit);
    void unlock();
} 
```

* `Condition`

* `ReentrantLock`  

基于`AQS`+`CAS`实现锁机制

`AQS`(AbstractQueuedSynchronizer)

```java
public class JUCLocksTest {
    /**
     * main
     * @param args
     */
    public static void main(String[] args) throws InterruptedException {
        A share = new A(0);
        for (int i = 0; i < 100; i++) {
            Thread t = new MyThread("Thread" + i, share);
            t.start();
        }

        Thread.sleep(10 * 1000);
    }
}

class MyThread extends Thread {

    private String name;
    private A share;

    MyThread(String name, A share) {
        this.name = name;
        this.share = share;
    }

    @Override
    public void run() {
        int sh = share.add();
        System.out.println(name + ":" + sh);
    }
}

class A {
    private int share;
    private ReentrantLock l = new ReentrantLock(true);


    A(int i) {
        this.share = i;
    }

    public int add() {
        l.lock();
        try {
            share++;
            return share;
        }finally {
            l.unlock();
        }
    }
}
```

* `ReentrantReadWriteLock`




5. `Future`, `Callable`, `FutureTask`

6. 线程池

7. `CountdownLatch`, `CyclicBarrier`, `Semaphor`

8. 生产者和消费者模型 

9. 并发容器`ConcurrentHashMap`


[Java多线程](https://www.caveofprogramming.com/library/index.html#java-multithreading)  
[Java语言规范](https://docs.oracle.com/javase/specs/jls/se16/html/jls-17.html)  
[Java内存模型](https://zhuanlan.zhihu.com/p/29881777)  
[Java轻量级锁与偏向锁](https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf)  
[Linux Mutex](https://www.kernel.org/doc/html/latest/locking/mutex-design.html)  